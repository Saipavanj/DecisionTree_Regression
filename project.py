# -*- coding: utf-8 -*-
"""project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xk8V99JbRx2ovqIGJ-uNHRjqR2ppwiED

#Importing required  libries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""#Reading the data from csv file"""

data=pd.read_csv("/content/Concrete Compressive Strength.csv")

data.shape

data.size

data.head()

data.tail()

data.describe()

"""#finding null values"""

data.isna().sum()

data.dtypes

data=data.rename(
    columns={"Concrete compressive strength(MPa, megapascals) ":'strength'}
)

"""#splitting the data into X and y 

"""

X=data.drop(["strength"],axis= 1)
y=data["strength"]

"""#visualization"""

X.hist()

sns.pairplot(data)

fig, ax = plt.subplots(figsize=(15,15))
sns.heatmap(data.corr(),annot=True,cmap='Accent')



class Node:
    def __init__(self, feature=None, threshold=None, left=None, right=None, value=None):
        self.feature = feature
        self.threshold = threshold
        self.left = left
        self.right = right
        self.value = value
        
class DecisionTreeRegressor:
    def __init__(self, max_depth=None, min_samples_split=2):
        self.max_depth = max_depth
        self.min_samples_split = min_samples_split
        
    def fit(self, X, y):
        self.root = self._build_tree(X, y)
        
    def predict(self, X):
        return np.array([self._traverse_tree(x, self.root) for x in X])
    
    def _build_tree(self, X, y, depth=0):
        n_samples, n_features = X.shape
        
        if depth == self.max_depth or n_samples < self.min_samples_split:
            return Node(value=np.mean(y))
        
        feature_idxs = np.random.choice(n_features, int(np.sqrt(n_features)), replace=False)
        
        best_feature, best_threshold = self._find_best_split(X, y, feature_idxs)
        
        left_idxs = X[:, best_feature] < best_threshold
        right_idxs = X[:, best_feature] >= best_threshold
        
        left = self._build_tree(X[left_idxs], y[left_idxs], depth+1)
        right = self._build_tree(X[right_idxs], y[right_idxs], depth+1)
        
        return Node(best_feature, best_threshold, left, right)
    
    def _find_best_split(self, X, y, feature_idxs):
        best_mse = float('inf')
        split_idx, split_threshold = None, None
        
        for feature_idx in feature_idxs:
            thresholds = np.unique(X[:, feature_idx])
            
            for threshold in thresholds:
                left_idxs = X[:, feature_idx] < threshold
                right_idxs = X[:, feature_idx] >= threshold
                
                if len(left_idxs) > 0 and len(right_idxs) > 0:
                    y_left = y[left_idxs]
                    y_right = y[right_idxs]
                    mse = self._mse(y_left) + self._mse(y_right)
                    
                    if mse < best_mse:
                        best_mse = mse
                        split_idx = feature_idx
                        split_threshold = threshold
                        
        return split_idx, split_threshold
    
    def _mse(self, y):
        if len(y) == 0:
            return 0
        else:
            return np.mean((y - np.mean(y))**2)
    
    def _traverse_tree(self, x, node):
        if node.value is not None:
            return node.value
        
        if x[node.feature] < node.threshold:
            return self._traverse_tree(x, node.left)
        else:
            return self._traverse_tree(x, node.right)

train = data.sample(frac=0.8, random_state=123)
test = data.drop(train.index)



X_train=train.drop("strength",axis=1)
y_train=train["strength"]
X_test =test.drop(["strength"],axis=1)
y_test =test["strength"]

regressior=DecisionTreeRegressor().fit(X,y)

predictions=DecisionTreeRegressor.predict(X_train,y_train)

